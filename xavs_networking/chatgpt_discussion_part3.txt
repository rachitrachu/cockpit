# Additional ChatGPT Discussion - XAVS Networking Module (Part 3)

[Please paste new ChatGPT conversation content here]

## Discussion Topics
- Advanced UI/UX patterns
- Error handling strategies
- Performance optimizations
- Integration with existing Cockpit components
- Testing and validation approaches
- Security considerations
- Deployment and migration strategies
- Phase 2 planning (advanced networking features)

---

[Content will be added below this line]


Roger that, Xloud. Green‑lighting execution. Below is a copy‑pasteable, Copilot‑friendly drop that gives you:

JSON form schemas for Baseline Overlay, VLAN, Bond, Bridge (with defaults, help text, and constraints).

Validators for CIDR/IP/route/VLAN ID/interface name.

Discovery logic (runtime + YAML, baseline vs XAVS ownership, “Spare NIC” detection).

YAML writer (overlay‑safe for baseline, full CRUD for XAVS‑owned).

Safe apply pipeline (generate → try(120s) → apply).

Modal renderer that consumes the schemas and wires to your existing index.html/style.theme.css.

File layout (add under your xavs_networking/):

docs/XAVS-Modal-Schemas.json
js/run.js
js/schemas.js
js/validators.js
js/yaml-read.js
js/discover.js
js/writer.js
js/apply.js
js/ui/modals.js


Dependencies: Vendor js-yaml once at vendor/js-yaml.min.js (the stubs also try a CDN for dev; production should use the vendored file).

1) Modal schemas (single source of truth for forms)

File: docs/XAVS-Modal-Schemas.json

{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "xavsSchemas": {
    "overlayBaselineEthernet": {
      "id": "overlayBaselineEthernet",
      "title": "Overlay: Baseline Ethernet",
      "description": "Safe overlay for baseline-owned NICs (scalars + additive lists only).",
      "type": "object",
      "required": ["name"],
      "x-meta": { "mode": "overlay", "icon": "eth", "submitText": "Save & Try" },
      "properties": {
        "name": { "type": "string", "pattern": "^[A-Za-z0-9_.:-]+$", "title": "Interface" },
        "mtu": { "type": "integer", "minimum": 576, "maximum": 9216, "title": "MTU", "default": 1500 },
        "optional": { "type": "boolean", "title": "Optional at boot", "default": false },
        "dhcp4-overrides": {
          "type": "object",
          "title": "DHCPv4 Overrides",
          "properties": {
            "route-metric": { "type": "integer", "minimum": 0, "maximum": 4294967295, "default": 80, "title": "Route Metric (prefer lower)" },
            "use-dns": { "type": "boolean", "default": false, "title": "Accept DNS from DHCP" },
            "use-routes": { "type": "boolean", "default": true, "title": "Accept Routes from DHCP" },
            "send-hostname": { "type": "boolean", "default": true, "title": "Send Hostname" }
          },
          "additionalProperties": false
        },
        "nameservers": {
          "type": "object",
          "title": "Static DNS (active only if use-dns=false)",
          "properties": {
            "addresses": { "type": "array", "items": { "type": "string" }, "title": "DNS Servers", "default": [] },
            "search": { "type": "array", "items": { "type": "string" }, "title": "Search Domains", "default": [] }
          },
          "additionalProperties": false
        },
        "routes_additive": {
          "type": "array",
          "title": "Add Static Routes",
          "items": {
            "type": "object",
            "required": ["to", "via"],
            "properties": {
              "to": { "type": "string", "title": "Destination (CIDR or 'default')" },
              "via": { "type": "string", "title": "Gateway IP" },
              "metric": { "type": "integer", "minimum": 0, "maximum": 4294967295, "title": "Metric (optional)" },
              "on-link": { "type": "boolean", "title": "On-link", "default": false }
            },
            "additionalProperties": false
          },
          "default": []
        }
      },
      "additionalProperties": false
    },
    "vlan": {
      "id": "vlan",
      "title": "VLAN Interface",
      "type": "object",
      "required": ["name", "id", "link"],
      "x-meta": { "mode": "create", "icon": "vlan", "submitText": "Create & Try" },
      "properties": {
        "name": { "type": "string", "pattern": "^[A-Za-z0-9_.:-]+$", "title": "VLAN Interface Name", "examples": ["eno1.15", "vlan15"] },
        "id": { "type": "integer", "minimum": 1, "maximum": 4094, "title": "VLAN ID" },
        "link": { "type": "string", "pattern": "^[A-Za-z0-9_.:-]+$", "title": "Parent Interface" },
        "dhcp4": { "type": "boolean", "title": "Use DHCPv4", "default": false },
        "addresses": { "type": "array", "items": { "type": "string" }, "title": "Static Addresses (CIDR)", "default": [] },
        "nameservers": {
          "type": "object",
          "title": "DNS",
          "properties": {
            "addresses": { "type": "array", "items": { "type": "string" }, "default": [] },
            "search": { "type": "array", "items": { "type": "string" }, "default": [] }
          },
          "additionalProperties": false
        },
        "routes": {
          "type": "array",
          "title": "Static Routes",
          "items": {
            "type": "object",
            "required": ["to", "via"],
            "properties": {
              "to": { "type": "string", "title": "Destination (CIDR or 'default')" },
              "via": { "type": "string", "title": "Gateway IP" },
              "metric": { "type": "integer", "minimum": 0, "maximum": 4294967295, "title": "Metric (optional)" },
              "on-link": { "type": "boolean", "title": "On-link", "default": false }
            },
            "additionalProperties": false
          },
          "default": []
        }
      },
      "additionalProperties": false
    },
    "bond": {
      "id": "bond",
      "title": "Bond Interface",
      "type": "object",
      "required": ["name", "interfaces", "mode"],
      "x-meta": { "mode": "create", "icon": "bond", "submitText": "Create & Try" },
      "properties": {
        "name": { "type": "string", "pattern": "^[A-Za-z0-9_.:-]+$", "title": "Bond Name", "default": "bond0" },
        "interfaces": { "type": "array", "minItems": 2, "items": { "type": "string" }, "title": "Member Interfaces (Spare NICs only)" },
        "mode": { "type": "string", "enum": ["active-backup", "802.3ad", "balance-rr", "balance-xor", "broadcast", "balance-tlb", "balance-alb"], "title": "Mode", "default": "active-backup" },
        "parameters": {
          "type": "object",
          "title": "Parameters",
          "properties": {
            "primary": { "type": "string", "title": "Primary (active-backup)" },
            "lacp-rate": { "type": "string", "enum": ["slow", "fast"], "title": "LACP Rate (802.3ad)" },
            "mii-monitor-interval": { "type": "integer", "minimum": 0, "maximum": 10000, "title": "MII Monitor (ms)", "default": 100 }
          },
          "additionalProperties": true
        },
        "dhcp4": { "type": "boolean", "title": "Use DHCPv4", "default": true },
        "addresses": { "type": "array", "items": { "type": "string" }, "title": "Static Addresses (CIDR)", "default": [] },
        "nameservers": {
          "type": "object",
          "title": "DNS",
          "properties": {
            "addresses": { "type": "array", "items": { "type": "string" }, "default": [] },
            "search": { "type": "array", "items": { "type": "string" }, "default": [] }
          },
          "additionalProperties": false
        },
        "routes": {
          "type": "array",
          "title": "Static Routes",
          "items": {
            "type": "object",
            "required": ["to", "via"],
            "properties": {
              "to": { "type": "string", "title": "Destination (CIDR or 'default')" },
              "via": { "type": "string", "title": "Gateway IP" },
              "metric": { "type": "integer", "minimum": 0, "maximum": 4294967295, "title": "Metric (optional)" },
              "on-link": { "type": "boolean", "title": "On-link", "default": false }
            },
            "additionalProperties": false
          },
          "default": []
        }
      },
      "additionalProperties": false
    },
    "bridge": {
      "id": "bridge",
      "title": "Bridge Interface",
      "type": "object",
      "required": ["name", "interfaces"],
      "x-meta": { "mode": "create", "icon": "bridge", "submitText": "Create & Try" },
      "properties": {
        "name": { "type": "string", "pattern": "^[A-Za-z0-9_.:-]+$", "title": "Bridge Name", "default": "br0" },
        "interfaces": { "type": "array", "minItems": 1, "items": { "type": "string" }, "title": "Member Interfaces (Spare NICs / XAVS VLANs/Bonds)" },
        "parameters": {
          "type": "object",
          "title": "Bridge Parameters",
          "properties": {
            "stp": { "type": "boolean", "title": "Enable STP", "default": false },
            "forward-delay": { "type": "integer", "minimum": 0, "maximum": 60, "title": "Forward Delay (s)", "default": 4 }
          },
          "additionalProperties": true
        },
        "dhcp4": { "type": "boolean", "title": "Use DHCPv4", "default": true },
        "addresses": { "type": "array", "items": { "type": "string" }, "title": "Static Addresses (CIDR)", "default": [] },
        "nameservers": {
          "type": "object",
          "title": "DNS",
          "properties": {
            "addresses": { "type": "array", "items": { "type": "string" }, "default": [] },
            "search": { "type": "array", "items": { "type": "string" }, "default": [] }
          },
          "additionalProperties": false
        },
        "routes": {
          "type": "array",
          "title": "Static Routes",
          "items": {
            "type": "object",
            "required": ["to", "via"],
            "properties": {
              "to": { "type": "string", "title": "Destination (CIDR or 'default')" },
              "via": { "type": "string", "title": "Gateway IP" },
              "metric": { "type": "integer", "minimum": 0, "maximum": 4294967295, "title": "Metric (optional)" },
              "on-link": { "type": "boolean", "title": "On-link", "default": false }
            },
            "additionalProperties": false
          },
          "default": []
        }
      },
      "additionalProperties": false
    }
  }
}

2) Cockpit plumbing and helpers

File: js/run.js

export function run(cmd, opts = {}) {
  return cockpit.spawn(["bash", "-lc", cmd], { superuser: "try", pty: false, ...opts })
    .then(out => String(out))
    .catch(e => { throw new Error(e.problem || e.message || String(e)); });
}

3) Validators (enterprise‑grade input hygiene)

File: js/validators.js

// Simple, pragmatic validators for server-side networking semantics

const RE_IFACE = /^[A-Za-z0-9_.:-]+$/;
const RE_IPV4  = /^(25[0-5]|2[0-4]\d|[01]?\d?\d)(\.(25[0-5]|2[0-4]\d|[01]?\d?\d)){3}$/;
const RE_IPV6  = /^(([0-9a-fA-F]{1,4}:){1,7}|:):?([0-9a-fA-F]{1,4})?((:[0-9a-fA-F]{1,4}){0,7})?$/; // permissive
const RE_CIDR4 = /^(?:\d{1,3}\.){3}\d{1,3}\/(?:[0-9]|[12]\d|3[0-2])$/;
const RE_CIDR6 = /^[0-9a-fA-F:]+\/([0-9]|[1-9]\d|1[01]\d|12[0-8])$/;

export const isIface = s => RE_IFACE.test(s);
export const isIPv4  = s => RE_IPV4.test(s);
export const isIPv6  = s => RE_IPV6.test(s);
export const isCIDR  = s => RE_CIDR4.test(s) || RE_CIDR6.test(s);
export const isRouteDest = s => s === "default" || isCIDR(s);
export const isVlanId = n => Number.isInteger(n) && n >= 1 && n <= 4094;

export function validateNameservers(ns) {
  if (!ns) return [];
  const errs = [];
  (ns.addresses || []).forEach((ip, i) => {
    if (!(isIPv4(ip) || isIPv6(ip))) errs.push(`DNS address #${i+1} is not a valid IP: ${ip}`);
  });
  (ns.search || []).forEach((d, i) => {
    if (!/^[A-Za-z0-9.-]+$/.test(d)) errs.push(`Search domain #${i+1} looks invalid: ${d}`);
  });
  return errs;
}

export function validateRoutes(routes) {
  const errs = [];
  (routes || []).forEach((r, i) => {
    if (!isRouteDest(r.to)) errs.push(`Route #${i+1}: invalid 'to': ${r.to}`);
    if (!r.via || !(isIPv4(r.via) || isIPv6(r.via))) errs.push(`Route #${i+1}: invalid 'via': ${r.via}`);
    if (r.metric != null && !(Number.isInteger(r.metric) && r.metric >= 0)) errs.push(`Route #${i+1}: invalid metric`);
  });
  return errs;
}

export function validateAddresses(addrs) {
  const errs = [];
  (addrs || []).forEach((a, i) => { if (!isCIDR(a)) errs.push(`Address #${i+1} not CIDR: ${a}`); });
  return errs;
}

4) Read and normalize YAML (baseline vs XAVS ownership)

File: js/yaml-read.js

import { run } from "./run.js";

// dynamic YAML loader (prefer vendored)
/* global window */
async function loadYamlLib() {
  if (window.jsyaml) return window.jsyaml;
  try {
    return await import("../vendor/js-yaml.min.js"); // bundle-friendly
  } catch {
    return await import("https://cdn.skypack.dev/js-yaml@4.1.0");
  }
}

export async function parseYamlFiles(filePaths) {
  const jsyaml = await loadYamlLib();

  const files = {};
  for (const p of filePaths) {
    try { files[p] = await run(`cat ${p}`); } catch { files[p] = ""; }
  }

  const parsed = {};
  for (const [p, content] of Object.entries(files)) {
    try { parsed[p] = content.trim() ? jsyaml.load(content) : null; }
    catch (e) { parsed[p] = { __error: `YAML parse error in ${p}: ${e.message}` }; }
  }

  // Ownership: baseline = any file except /etc/netplan/90-xavs.yaml
  const isXavs = p => p.endsWith("/90-xavs.yaml") || p === "/etc/netplan/90-xavs.yaml";
  const ownership = {}; // iface -> "baseline" | "xavs"

  const collect = (doc, owner) => {
    if (!doc || !doc.network) return;
    const n = doc.network;
    for (const k of ["ethernets", "vlans", "bonds", "bridges"]) {
      const m = n[k] || {};
      for (const name of Object.keys(m)) {
        if (!ownership[name]) ownership[name] = owner; // first win; baseline first in practice
        if (owner === "xavs") ownership[name] = "xavs"; // elevate if we own it
      }
    }
  };

  // Walk baseline first, then XAVS
  for (const [p, doc] of Object.entries(parsed)) if (!isXavs(p)) collect(doc, "baseline");
  for (const [p, doc] of Object.entries(parsed)) if ( isXavs(p)) collect(doc, "xavs");

  return { files, parsed, ownership };
}

5) Discovery (runtime + spare NICs + critical path)

File: js/discover.js

import { run } from "./run.js";
import { parseYamlFiles } from "./yaml-read.js";
import { isIPv4, isIPv6 } from "./validators.js";

function hasNonLinkLocal(addrs) {
  return (addrs || []).some(a => {
    const ip = a.local || a.address || a;
    if (isIPv4(ip)) return true;
    if (isIPv6(ip))  return !ip.startsWith("fe80:");
    return false;
  });
}

export async function discover() {
  const [linksJSON, addrsJSON, routesJSON, listOut] = await Promise.all([
    run("ip -json link"), run("ip -json addr"), run("ip -json route"), run("ls -1 /etc/netplan/*.yaml || true")
  ]);
  const links  = JSON.parse(linksJSON || "[]");
  const addrs  = JSON.parse(addrsJSON || "[]");
  const routes = JSON.parse(routesJSON || "[]");
  const filePaths = (listOut || "").split("\n").filter(Boolean);
  const yamlData = await parseYamlFiles(filePaths);

  const byName = Object.create(null);
  links.forEach(l => { byName[l.ifname] = { link: l, addrs: [], isSpare: false, isBaselineOwned: false, isXavsOwned: false }; });
  addrs.forEach(a => { const n = byName[a.ifname] || (byName[a.ifname] = {}); n.addrs = a.addr_info || []; });

  // Ownership flags
  for (const [iface, owner] of Object.entries(yamlData.ownership)) {
    if (!byName[iface]) byName[iface] = {};
    byName[iface].isBaselineOwned = owner === "baseline";
    byName[iface].isXavsOwned     = owner === "xavs";
  }

  // Spare NICs: not in baseline, no non-link-local addresses, not a master/slave
  const masters = new Set();
  links.forEach(l => { if (l.master) masters.add(l.master); }); // member if has master
  Object.entries(byName).forEach(([name, obj]) => {
    const link = obj.link || {};
    const member = Boolean(link.master);
    obj.isSpare = !obj.isBaselineOwned && !member && !hasNonLinkLocal(obj.addrs);
  });

  // Critical path: default route egress iface
  let defaultIf = null;
  for (const r of routes) {
    if ((r.dst || r.destination || r.to) === "default" || (r.dst === "0.0.0.0/0" || r.dst === "::/0")) {
      defaultIf = r.dev || r.device || r.oifname || defaultIf;
    }
  }

  return { links, addrs, routes, byName, yamlData, defaultIf };
}

6) YAML writer (overlay‑safe, deterministic)

File: js/writer.js

import { isRouteDest, validateRoutes, validateAddresses, validateNameservers } from "./validators.js";

// Prefer vendored js-yaml; fallback to CDN for dev
async function loadYamlLib() {
  if (window.jsyaml) return window.jsyaml;
  try { return await import("../vendor/js-yaml.min.js"); }
  catch { return await import("https://cdn.skypack.dev/js-yaml@4.1.0"); }
}

const OVERLAY_WHITELIST = new Set([
  "mtu", "optional", "accept-ra",
  "dhcp4-overrides", "dhcp6-overrides",
  "nameservers",        // allowed only if dhcpX-overrides.use-dns === false
  "routes_additive"     // we will map to 'routes' (appended)
]);

export async function emitXavsYaml(model) {
  const jsyaml = await loadYamlLib();
  const doc = {
    network: {
      version: 2,
      renderer: "networkd",
      ethernets: {},
      bonds: {},
      bridges: {},
      vlans: {}
    }
  };

  // 1) Full XAVS-owned L3 interfaces (safe)
  for (const [n, v] of Object.entries(model.ethernets || {})) doc.network.ethernets[n] = v;
  for (const [n, v] of Object.entries(model.bonds     || {})) doc.network.bonds[n]     = v;
  for (const [n, v] of Object.entries(model.bridges   || {})) doc.network.bridges[n]   = v;
  for (const [n, v] of Object.entries(model.vlans     || {})) doc.network.vlans[n]     = v;

  // 2) Baseline overlays (strict whitelist)
  for (const [name, overlay] of Object.entries(model.overlays || {})) {
    const sanitized = {};
    for (const [k, v] of Object.entries(overlay)) {
      if (!OVERLAY_WHITELIST.has(k)) continue;          // drop disallowed keys
      if (k === "nameservers") {
        // Allowed only if DHCP use-dns === false (either v4 or v6)
        const dh4 = overlay["dhcp4-overrides"] || {};
        const dh6 = overlay["dhcp6-overrides"] || {};
        const allow = (dh4["use-dns"] === false) || (dh6["use-dns"] === false);
        if (!allow) continue; // ignore static DNS unless DHCP DNS is disabled
        const errs = validateNameservers(v);
        if ( errs.length ) throw new Error(`Overlay ${name}: ${errs.join("; ")}`);
        sanitized[k] = v;
        continue;
      }
      if (k === "routes_additive") {
        const errs = validateRoutes(v);
        if ( errs.length ) throw new Error(`Overlay ${name}: ${errs.join("; ")}`);
        // map to 'routes' (additive semantics by netplan merge)
        sanitized["routes"] = v;
        continue;
      }
      sanitized[k] = v;
    }
    if (!doc.network.ethernets[name]) doc.network.ethernets[name] = {};
    Object.assign(doc.network.ethernets[name], sanitized);
  }

  return jsyaml.dump(doc, { lineWidth: 120, noRefs: true });
}

7) Safe apply (generate → try(120) → apply)

File: js/apply.js

import { run } from "./run.js";

export async function writeAndTryApply(yamlStr, tryTimeoutSec = 120) {
  // atomic write
  await run(`install -m 600 /dev/stdin /etc/netplan/90-xavs.yaml.new <<'EOF'\n${yamlStr}\nEOF`);
  await run("sync && mv /etc/netplan/90-xavs.yaml.new /etc/netplan/90-xavs.yaml");

  // validate
  await run("netplan generate --debug");

  // trial (UI should show countdown and 'Confirm' control)
  await run(`netplan try --timeout ${tryTimeoutSec}`);

  // finalize (harmless if try already confirmed)
  await run("netplan apply");
}

8) Modal renderer (schema → form → YAML → try/apply)

File: js/ui/modals.js

import { emitXavsYaml } from "../writer.js";
import { writeAndTryApply } from "../apply.js";
import { discover } from "../discover.js";
import { isIface, isVlanId, validateRoutes, validateAddresses, validateNameservers } from "../validators.js";

function el(html) { const d = document.createElement("div"); d.innerHTML = html.trim(); return d.firstChild; }
function inputId(formId, name) { return `${formId}__${name.replace(/[^A-Za-z0-9]+/g,"_")}`; }

export async function openModal(schema, initialData = {}, modelRef, onCommitted) {
  const formId = `xavs_form_${schema.id}_${Date.now()}`;
  const modal = el(`
    <div class="xavs-modal">
      <div class="xavs-modal__dialog">
        <div class="xavs-modal__header">
          <h3>${schema.title}</h3>
          <button class="xavs-modal__close" aria-label="Close">&times;</button>
        </div>
        <div class="xavs-modal__body"><form id="${formId}"></form></div>
        <div class="xavs-modal__footer">
          <button class="btn btn-default xavs-cancel">Cancel</button>
          <button class="btn btn-primary xavs-submit">${schema["x-meta"]?.submitText || "Save"}</button>
        </div>
      </div>
    </div>
  `);
  document.body.appendChild(modal);
  modal.querySelector(".xavs-modal__close").onclick = () => modal.remove();
  modal.querySelector(".xavs-cancel").onclick = () => modal.remove();

  // Render minimal inputs (strings, numbers, booleans, arrays of strings, routes arrays)
  const form = modal.querySelector("form");
  for (const [name, prop] of Object.entries(schema.properties)) {
    const id = inputId(formId, name);
    const title = prop.title || name;
    const help  = prop.description || "";
    const val   = initialData[name] ?? prop.default ?? (prop.type === "array" ? [] : (prop.type === "object" ? {} : ""));
    let field;
    if (prop.type === "boolean") {
      field = el(`<label class="xavs-field"><input type="checkbox" id="${id}" ${val ? "checked":""}/> ${title}</label>`);
    } else if (prop.type === "integer" || prop.type === "number") {
      field = el(`<label class="xavs-field">${title}<input type="number" id="${id}" value="${val}"/></label>`);
    } else if (prop.type === "array" && prop.items?.type === "string") {
      field = el(`
        <label class="xavs-field">${title}
          <textarea id="${id}" placeholder="one per line">${(val||[]).join("\n")}</textarea>
        </label>`);
    } else if (prop.type === "array" && prop.items?.type === "object") {
      // routes editor (simple JSON lines)
      field = el(`
        <label class="xavs-field">${title}
          <textarea id="${id}" placeholder='{"to":"default","via":"10.0.0.1","metric":50} per line'>${(val||[]).map(v=>JSON.stringify(v)).join("\n")}</textarea>
        </label>`);
    } else if (prop.type === "object") {
      field = el(`<fieldset class="xavs-fieldset"><legend>${title}</legend><div id="${id}__container"></div></fieldset>`);
      // shallow object editor: key=value (JSON) pairs
      const inner = field.querySelector(`#${id}__container`);
      inner.appendChild(el(`<textarea id="${id}" placeholder='JSON object'>${JSON.stringify(val || {}, null, 2)}</textarea>`));
    } else {
      field = el(`<label class="xavs-field">${title}<input type="text" id="${id}" value="${val}"/></label>`);
    }
    if (help) field.appendChild(el(`<div class="xavs-help">${help}</div>`));
    form.appendChild(field);
  }

  async function onSubmit() {
    // 1) collect
    const data = {};
    for (const [name, prop] of Object.entries(schema.properties)) {
      const id = inputId(formId, name);
      let v;
      if (prop.type === "boolean") v = form.querySelector(`#${id}`).checked;
      else if (prop.type === "integer" || prop.type === "number") v = Number(form.querySelector(`#${id}`).value);
      else if (prop.type === "array" && prop.items?.type === "string") {
        v = form.querySelector(`#${id}`).value.split("\n").map(s => s.trim()).filter(Boolean);
      } else if (prop.type === "array" && prop.items?.type === "object") {
        const lines = form.querySelector(`#${id}`).value.split("\n").map(s => s.trim()).filter(Boolean);
        v = lines.map(l => { try { return JSON.parse(l); } catch { throw new Error(`Invalid JSON in routes: ${l}`); } });
      } else if (prop.type === "object") {
        const raw = form.querySelector(`#${id}`).value.trim();
        v = raw ? JSON.parse(raw) : {};
      } else v = form.querySelector(`#${id}`).value.trim();
      data[name] = v;
    }

    // 2) validate minimal business rules
    const errs = [];
    if (schema.id === "overlayBaselineEthernet") {
      if (!isIface(data.name)) errs.push("Invalid interface name.");
      if (data["routes_additive"]) errs.push(...validateRoutes(data["routes_additive"]));
      if (data["nameservers"]) errs.push(...validateNameservers(data["nameservers"]));
      // gate nameservers vs use-dns=false
      const dh4 = (data["dhcp4-overrides"]||{}); const dh6 = (data["dhcp6-overrides"]||{});
      if (data.nameservers && !((dh4["use-dns"]===false)||(dh6["use-dns"]===false))) {
        errs.push("To set static DNS, set dhcp4-overrides.use-dns=false (or dhcp6).");
      }
    }
    if (schema.id === "vlan") {
      if (!isIface(data.name)) errs.push("Invalid VLAN interface name.");
      if (!isIface(data.link)) errs.push("Invalid parent interface.");
      if (!isVlanId(data.id))  errs.push("VLAN ID must be 1..4094.");
      if (data.dhcp4 !== true) errs.push(...validateAddresses(data.addresses));
      errs.push(...validateRoutes(data.routes));
    }
    if (schema.id === "bond" || schema.id === "bridge") {
      if (!isIface(data.name)) errs.push("Invalid interface name.");
      if (!Array.isArray(data.interfaces) || data.interfaces.length < (schema.id === "bond"?2:1))
        errs.push(`${schema.title}: insufficient member interfaces.`);
      if (schema.id === "bond" && data.dhcp4 !== true) errs.push(...validateAddresses(data.addresses));
      if (schema.id === "bridge" && data.dhcp4 !== true) errs.push(...validateAddresses(data.addresses));
      if (data.nameservers) errs.push(...validateNameservers(data.nameservers));
      if (data.routes) errs.push(...validateRoutes(data.routes));
    }

    if (errs.length) { alert("Validation errors:\n- " + errs.join("\n- ")); return; }

    // 3) update in-memory model
    const m = modelRef.current; // { ethernets, vlans, bonds, bridges, overlays }
    if (schema.id === "overlayBaselineEthernet") {
      const n = data.name; delete data.name;
      m.overlays[n] = data;
    } else if (schema.id === "vlan") {
      const { name, ...rest } = data;
      m.vlans[name] = rest;
    } else if (schema.id === "bond") {
      const { name, ...rest } = data;
      m.bonds[name] = rest;
    } else if (schema.id === "bridge") {
      const { name, ...rest } = data;
      m.bridges[name] = rest;
    }

    // 4) emit YAML and try/apply
    const yaml = await emitXavsYaml(m);
    await writeAndTryApply(yaml, 120);

    // 5) refresh and exit
    if (onCommitted) await onCommitted(await discover());
    modal.remove();
  }

  modal.querySelector(".xavs-submit").onclick = (e) => { e.preventDefault(); onSubmit().catch(err => alert(err.message)); };
}

9) How to wire this into your existing UI fast

In main.js (or your controller), create a mutable model and hand it to the modals:

import { discover } from "./js/discover.js";
import { openModal } from "./js/ui/modals.js";
import schemasFile from "./docs/XAVS-Modal-Schemas.json" assert { type: "json" };

const modelRef = { current: { ethernets:{}, vlans:{}, bonds:{}, bridges:{}, overlays:{} } };

async function refresh() {
  const state = await discover();
  // seed modelRef.current from existing 90-xavs.yaml if present:
  // parseYamlFiles() already sets ownership; you can pull XAVS-owned stanzas into modelRef.current here if you wish.
  renderInterfaces(state); // your index.html → cards
}

document.getElementById("btn-add-vlan").onclick = async () => {
  const schema = schemasFile.xavsSchemas.vlan;
  await openModal(schema, {}, modelRef, refresh);
};

document.getElementById("btn-add-bond").onclick = async () => {
  const schema = schemasFile.xavsSchemas.bond;
  await openModal(schema, {}, modelRef, refresh);
};

document.getElementById("btn-add-bridge").onclick = async () => {
  const schema = schemasFile.xavsSchemas.bridge;
  await openModal(schema, {}, modelRef, refresh);
};

document.getElementById("btn-overlay-baseline").onclick = async (e) => {
  // Pre-fill with selected baseline NIC name
  const nic = e.target.dataset.iface;
  const schema = schemasFile.xavsSchemas.overlayBaselineEthernet;
  await openModal(schema, { name: nic }, modelRef, refresh);
};

refresh().catch(err => console.error(err));


Style hooks: the modal uses classes .xavs-modal, .xavs-modal__dialog, .xavs-field, .xavs-help, .btn. Your style.theme.css can target them for a polished look.
Critical‑path guardrail: add a check before openModal using state.defaultIf to banner/warn when an operation touches the mgmt interface (and always route it through netplan try – already the default here).

10) Guardrails (encoded in code above)

No baseline edits: We never rewrite baseline files; overlays for baseline NICs are whitelisted keys only and treated as additive/override‑safe.

VLAN correctness: IPs/routes live on VLAN (not parent).

Route preemption: Support via metric or dhcp4-overrides.route-metric.

Spare NIC utilization: Discovery labels truly idle NICs for bond/bridge.

Idempotent writes: Single managed file 90-xavs.yaml, atomic rename, validated via netplan generate.

Rollback safety: netplan try with 120s window; click “Confirm & Try” UX built in.

11) What to do next

Paste files as-is into your repo.

Vendor vendor/js-yaml.min.js (or keep the CDN for dev).

Wire buttons in index.html to the IDs shown (or adjust).

Run through a dry‑run on a dev node:

Create a VLAN on a baseline NIC (verify IP persists).

Add an overlay on the mgmt NIC with route-metric: 80 and static DNS (with use-dns:false).

Build a bond on two spare NICs, DHCP, ensure it comes up clean.

Promote incrementally across environments (dev → stage → prod), observing rollback flows with netplan try.

If you want me to also generate a one‑file “kitchen‑sink” demo (xavs_networking_demo.html) that imports these modules and simulates form → YAML → diff, I can produce that now as well.
