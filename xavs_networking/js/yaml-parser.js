/**
 * XAVS Networking YAML Parser Module (2024)
 * Production-grade YAML parsing, writing, normalization, and merging
 * Handles Netplan-specific semantics and safe overlay merging
 */

import { run } from "./run.js";

// Using dynamic import for js-yaml
let yaml;

async function loadYaml() {
  if (!yaml) {
    yaml = await import("https://cdn.skypack.dev/js-yaml@4.1.0");
  }
  return yaml;
}

const XAVSYAMLParser = {
  
  // **1. Core YAML Operations**
  
  async parseYAML(yamlContent) {
    try {
      const yamlLib = await loadYaml();
      
      if (!yamlContent || typeof yamlContent !== 'string') {
        throw new Error('YAML content must be a non-empty string');
      }
      
      const parsed = yamlLib.load(yamlContent);
      
      // Validate basic Netplan structure
      if (parsed && typeof parsed === 'object' && !parsed.network) {
        console.warn('Warning: YAML does not contain a "network" key - may not be a valid Netplan file');
      }
      
      return parsed;
    } catch (error) {
      throw new Error(`YAML parse error: ${error.message}`);
    }
  },
  
  async generateYAML(configObject) {
    try {
      const yamlLib = await loadYaml();
      
      if (!configObject || typeof configObject !== 'object') {
        throw new Error('Config object must be a valid object');
      }
      
      // Production YAML formatting options
      const options = {
        indent: 2,                  // Netplan standard
        lineWidth: 120,             // Reasonable line length
        quotingType: '"',           // Consistent quoting
        forceQuotes: false,         // Only quote when necessary
        sortKeys: false,            // Preserve order
        flowLevel: -1,              // Always use block style
        noRefs: true,               // No YAML references
        skipInvalid: false,         // Strict mode
        condenseFlow: false         // Readable formatting
      };
      
      const yamlOutput = yamlLib.dump(configObject, options);
      
      // Add standard Netplan header comment
      const header = `# Netplan configuration generated by XAVS Networking\n# Do not edit manually - use Cockpit XAVS interface\n\n`;
      
      return header + yamlOutput;
    } catch (error) {
      throw new Error(`YAML generation error: ${error.message}`);
    }
  },
  
  // **2. File-Based Operations**
  
  async parseYamlFiles(filePaths) {
    const result = {
      baseline: {},
      xavs: {},
      merged: {},
      perFile: {}
    };
    
    for (const filePath of filePaths) {
      try {
        const content = await run(`cat "${filePath}"`);
        const parsed = await this.parseYAML(content);
        
        const fileName = filePath.split('/').pop();
        result.perFile[fileName] = parsed;
        
        // Categorize by file type
        if (fileName.includes('installer-config') || fileName.startsWith('00-')) {
          Object.assign(result.baseline, parsed?.network || {});
        } else if (fileName === '90-xavs.yaml') {
          Object.assign(result.xavs, parsed?.network || {});
        }
        
        // Build merged view (later files override earlier)
        if (parsed?.network) {
          this.mergeNetplanConfig(result.merged, parsed.network);
        }
      } catch (error) {
        console.warn(`Failed to parse ${filePath}:`, error);
      }
    }
    
    return result;
  },
  
  // **3. Netplan-Specific Normalization**
  
  normalizeNetplanKeys(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    if (Array.isArray(obj)) return obj.map(item => this.normalizeNetplanKeys(item));
    
    const normalized = {};
    
    for (const [key, value] of Object.entries(obj)) {
      // Convert underscore keys to hyphen keys (Netplan canonical form)
      const netplanKey = key.replace(/_/g, '-');
      
      // Recursively normalize nested objects
      if (value && typeof value === 'object') {
        normalized[netplanKey] = this.normalizeNetplanKeys(value);
      } else {
        normalized[netplanKey] = value;
      }
    }
    
    return normalized;
  },
  
  normalizeConfiguration(config) {
    if (!config) return config;
    return this.normalizeNetplanKeys(config);
  },
  
  // **4. Netplan Merging**
  
  mergeNetplanConfig(target, source) {
    // Implement Netplan's merge rules:
    // - Scalars override
    // - Arrays replace (not merge)
    // - Objects merge recursively
    
    for (const [key, value] of Object.entries(source)) {
      if (value === null || value === undefined) {
        continue;
      }
      
      if (typeof value === 'object' && !Array.isArray(value)) {
        // Recursive merge for objects
        if (!target[key]) target[key] = {};
        this.mergeNetplanConfig(target[key], value);
      } else {
        // Direct replacement for scalars and arrays
        target[key] = value;
      }
    }
  }
  
};

// **5. Helper Functions for Interface Management**

export async function parseYamlFiles(filePaths) {
  return await XAVSYAMLParser.parseYamlFiles(filePaths);
}

export function checkInterfaceInConfig(interfaceName, config) {
  if (!config || typeof config !== 'object') return false;
  
  const interfaceTypes = ['ethernets', 'vlans', 'bonds', 'bridges', 'tunnels', 'wifis'];
  
  for (const type of interfaceTypes) {
    if (config[type] && config[type][interfaceName]) {
      return { type, config: config[type][interfaceName] };
    }
  }
  
  return false;
}

export function getInterfaceOwnership(interfaceName, yamlInfo) {
  // Check if interface exists in baseline configuration
  const isInBaseline = checkInterfaceInConfig(interfaceName, yamlInfo.baseline);
  const isInXAVS = checkInterfaceInConfig(interfaceName, yamlInfo.xavs);
  
  if (isInBaseline && isInXAVS) {
    return 'overlay'; // XAVS overlay on baseline interface
  } else if (isInBaseline) {
    return 'baseline'; // Baseline-only interface
  } else if (isInXAVS) {
    return 'xavs'; // XAVS-created interface
  } else {
    return 'unknown'; // Not found in either
  }
}

export default XAVSYAMLParser;
