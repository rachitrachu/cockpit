/* global cockpit */

(() => {
    'use strict';

    // ——— helpers ———
    const $  = (id) => document.getElementById(id);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const setBadge = (id, cls, text) => {
        const el = $(id);
        if (!el) return;
        el.className = "badge " + (cls || "");
        el.textContent = text || "—";
    };
    const setText = (id, text) => {
        const el = $(id);
        if (el) el.textContent = text;
    };
    const pb = (id, v) => {
        const el = $(id);
        if (el) el.style.width = Math.max(0, Math.min(100, v)) + "%";
    };
    const logEl = $("log");
    const log = (t="") => {
        if (!logEl) return;
        logEl.textContent += t + "\n";
        logEl.scrollTop = logEl.scrollHeight;
    };

    // ——— tab management ———
    let currentPanel = 'panel-overview';
    const links = $$('#tabs .nav-link');
    console.debug('[tabs] Found tab links:', links.map(l => l.dataset.target || l.textContent.trim()));
    
    function showPanel(panelId) {
        if (panelId === currentPanel) return;
        console.debug('[tabs] Showing panel:', panelId);
        
        // Hide all panels first
        $$('.tab-pane').forEach(p => {
            p.classList.remove('active', 'show');
            p.setAttribute('aria-hidden', 'true');
        });
        
        // Deactivate all nav links
        $$('.nav-link').forEach(a => a.classList.remove('active'));
        
        // Show target panel
        const panel = $('#' + panelId);
        const link = links.find(a => a.dataset.target === panelId);
        
        if (panel) {
            // Add active class first
            panel.classList.add('active');
            // Then add show class after a brief delay for transition
            setTimeout(() => panel.classList.add('show'), 50);
            panel.setAttribute('aria-hidden', 'false');
        }
        
        if (link) {
            link.classList.add('active');
        }

        currentPanel = panelId;
    }

    // Wire up tab clicks
    links.forEach(a => a.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPanel = a.dataset.target;
        showPanel(targetPanel);
        
        // Run checks when switching to these tabs
        if (targetPanel === 'panel-hw')   runHardwareChecks().catch(console.error);
        if (targetPanel === 'panel-deps')  checkDependencies().catch(console.error);
    }));

    // ——— OS Detection ———
    let osInfo = {
        name: "Unknown",
        id: "",
        like: "",
        version: "",
        kernel: "",
        isXOS: false,
        branch: "unknown"
    };

    async function detectOS() {
        try {
            setText("os-name", "Detecting…");
            const out = await cockpit.spawn([
                "bash", "-c", 
                "source /etc/os-release 2>/dev/null; echo \"$NAME|$ID|$ID_LIKE|$VERSION_ID\""
            ]);
            const ker = await cockpit.spawn(["uname", "-r"]);
            
            const [name, id, like, ver] = (out.trim() || "Unknown|||").split("|");
            osInfo = {
                name: name || "Unknown",
                id: id || "",
                like: like || "",
                version: ver || "",
                kernel: ker.trim(),
                isXOS: /xos/i.test(name) || /xos/i.test(id),
                branch: "unknown"
            };

            // Determine OS branch
            if (/debian|ubuntu/i.test(osInfo.id) || /debian|ubuntu/i.test(osInfo.like)) {
                osInfo.branch = "debian";
            } else if (/rhel|rocky|centos|almalinux/i.test(osInfo.id) || /rhel|rocky|centos|almalinux/i.test(osInfo.like)) {
                osInfo.branch = "rhel";
            }

            // Update UI
            setText("os-name", osInfo.name + (osInfo.version ? " " + osInfo.version : ""));
            setText("os-kernel", osInfo.kernel);
            setText("os-branch", osInfo.branch === "debian" ? "Debian/Ubuntu" : 
                               osInfo.branch === "rhel" ? "RHEL/Rocky/CentOS" : "Unknown");
            setText("os-mode", osInfo.isXOS ? "XOS: hardware-only checks" : "Standard: HW + packages");

            // Update XOS banner visibility
            const banner = $("xos-reco");
            if (banner) banner.style.display = osInfo.isXOS ? "none" : "";

            // Update Dependencies UI state
            setText("dep-branch", osInfo.isXOS ? "XOS (skips packages)" : 
                                osInfo.branch === "debian" ? "Debian/Ubuntu" :
                                osInfo.branch === "rhel" ? "RHEL/Rocky/CentOS" : "Unknown");

            const depGrid = $("dep-grid");
            const installBtn = $("btn-install-all");
            const checkBtn = $("btn-check-deps");

            if (osInfo.isXOS) {
                if (depGrid) depGrid.style.opacity = "0.5";
                if (installBtn) installBtn.disabled = true;
                if (checkBtn) checkBtn.disabled = true;
                setText("dep-status", "Skipped on XOS");
            } else {
                if (depGrid) depGrid.style.opacity = "1";
                if (installBtn) installBtn.disabled = false;
                if (checkBtn) checkBtn.disabled = false;
                setText("dep-status", "Ready");
            }

            log(`[OS] ${osInfo.name} (id=${osInfo.id}, like=${osInfo.like}) kernel=${osInfo.kernel} branch=${osInfo.branch} XOS=${osInfo.isXOS}`);
        } catch (error) {
            setText("os-name", "Unknown");
            setText("os-kernel", "—");
            setText("os-branch", "—");
            setText("os-mode", "—");
            log("[OS] Detection failed: " + error.message || error);
        }
    }

    // ——— Hardware Checks ———
    async function runHardwareChecks() {
        // Reset badges
        ['root', 'nics', 'extra', 'cores', 'ram'].forEach(id => 
            setBadge(`chk-${id}`, "", "…")
        );
        setText("hw-summary", "");

        try {
            // Check root space
            const df = await cockpit.spawn([
                "bash", "-c",
                "df -BG / | awk 'NR==2{gsub(\"G\",\"\",$4); print $4}'"
            ]);
            const freeSpace = parseInt(df.trim(), 10) || 0;
            setBadge("chk-root", freeSpace >= 100 ? "ok" : "err", `${freeSpace} GB`);

            // Check network interfaces
            const nc = await cockpit.spawn([
                "bash", "-c",
                "ls -1 /sys/class/net | grep -v '^lo$' | wc -l"
            ]);
            const nics = parseInt(nc.trim(), 10) || 0;
            setBadge("chk-nics", nics >= 2 ? "ok" : "err", String(nics));

            // Check for extra storage
            const storageCheck = 
                "rootdev=$(findmnt -n -o SOURCE / | sed 's/[0-9]*$//');" +
                "disks=$(lsblk -dn -o NAME,TYPE | awk '$2==\"disk\"{print \"/dev/\"$1}');" +
                "extra=0; for d in $disks; do " +
                "  if [ \"$d\" != \"$rootdev\" ]; then " +
                "    parts=$(lsblk -no NAME,MOUNTPOINT \"$d\" | tail -n +2 | awk 'NF');" +
                "    [ -z \"$parts\" ] && extra=1 && break;" +
                "  fi;" +
                "done;" +
                "if [ $extra -eq 0 ]; then " +
                "  if command -v vgs >/dev/null 2>&1; then " +
                "    vgs --noheadings -o vg_name,lv_count,vg_free | " +
                "    awk '($2==0)||($3!~/0B/){found=1} END{exit !(found)}' && " +
                "    echo YES || echo NO;" +
                "  else echo NO; fi;" +
                "else echo YES; fi";

            const extra = (await cockpit.spawn(["bash", "-c", storageCheck])).trim() === "YES";
            setBadge("chk-extra", extra ? "ok" : "warn", extra ? "Available" : "Not found");

            // Check CPU cores
            const cores = parseInt((await cockpit.spawn(["nproc"])).trim(), 10) || 0;
            setBadge("chk-cores", cores >= 4 ? "ok" : "err", String(cores));

            // Check RAM
            const meminfo = await cockpit.spawn([
                "bash", "-c",
                "awk '/MemTotal/ {print int($2/1024/1024)}' /proc/meminfo"
            ]);
            const ramGB = parseInt(meminfo.trim(), 10) || 0;
            setBadge("chk-ram", ramGB >= 8 ? "ok" : "err", `${ramGB} GB`);

            // Summarize results
            const errors = ['root', 'nics', 'cores', 'ram']
                .filter(id => $(`chk-${id}`).className.includes("err"));
            const warnings = ['extra']
                .filter(id => $(`chk-${id}`).className.includes("warn"));

            let summary = "";
            if (errors.length) {
                summary += "❌ Fix red items before proceeding. ";
            }
            if (warnings.length) {
                summary += "⚠️ Additional disk/VG not found — block storage won't be used; ephemeral only.";
            }
            setText("hw-summary", summary);

            log(`[HW] root=${freeSpace}G nics=${nics} extra=${extra} cores=${cores} ram=${ramGB}G`);
        } catch (error) {
            setText("hw-summary", "Check failed. See logs.");
            log("[HW] Failed: " + error.message || error);
        }
    }

    // ——— Dependencies ———
    async function checkDependencies() {
        if (osInfo.isXOS) {
            setText("dep-status", "Skipped on XOS");
            return;
        }

        if (osInfo.branch === "debian") {
            await checkDebianDeps();
        } else if (osInfo.branch === "rhel") {
            await checkRHELDeps();
        } else {
            setText("dep-status", "Unknown OS");
        }
    }

    async function checkDebianDeps() {
        const script = `
            set -e
            step() { echo "[STEP] $1"; }
            
            # Python deps
            pkgs='git python3-dev libffi-dev gcc libssl-dev python3-venv python3-docker'
            missing=$(dpkg-query -W -f='\${Status} \${Package}\\n' $pkgs 2>/dev/null | 
                     awk '$3!="installed"{print $5}')
            [ -z "$missing" ] && echo PY_OK || echo PY_MISS

            # Environment
            [ -d /opt/xenv ] && echo ENV_OK || echo ENV_MISS

            # xDeploy deps
            if [ -x /opt/xenv/bin/python ]; then
                /opt/xenv/bin/python - <<'PY'
import pkgutil, packaging.version as pv
try:
    import ansible
    ok1 = pv.parse(ansible.__version__).release[:2]==(2,15)
except Exception:
    ok1 = False
ok2 = pkgutil.find_loader('kolla_ansible') is not None
print('XDEP_OK' if (ok1 and ok2) else 'XDEP_MISS')
PY
            else 
                echo XDEP_MISS
            fi

            # Config & passwords
            [ -d /etc/xavs ] && echo CFG_OK || echo CFG_MISS
            [ -f /etc/xavs/passwords.yml ] || [ -f /etc/kolla/passwords.yml ] && 
            echo PWD_OK || echo PWD_MISS
        `;

        try {
            const out = await cockpit.spawn(["bash", "-c", script], { superuser: "try" });
            const results = out.trim().split("\n");
            
            setBadge("dep-py",    results.includes("PY_OK")   ? "ok" : "err", results.includes("PY_OK")   ? "ok" : "missing");
            setBadge("dep-env",   results.includes("ENV_OK")  ? "ok" : "err", results.includes("ENV_OK")  ? "present" : "missing");
            setBadge("dep-xdep",  results.includes("XDEP_OK") ? "ok" : "err", results.includes("XDEP_OK") ? "ok" : "missing");
            setBadge("dep-cfg",   results.includes("CFG_OK")  ? "ok" : "err", results.includes("CFG_OK")  ? "ready" : "missing");
            setBadge("dep-pwd",   results.includes("PWD_OK")  ? "ok" : "warn", results.includes("PWD_OK") ? "ready" : "generate");
            
            setText("dep-status", "Checked");
            log("[Deps:Debian] Check\n" + out.trim());
        } catch (error) {
            log("[Deps:Debian] Check failed: " + error.message || error);
        }
    }

    async function checkRHELDeps() {
        const script = `
            set -e
            step() { echo "[STEP] $1"; }
            
            # Python deps
            missing=$(rpm -q git python3-devel libffi-devel gcc openssl-devel python3-libselinux 2>/dev/null |
                     awk '/is not installed/{print $1}')
            [ -z "$missing" ] && echo PY_OK || echo PY_MISS

            echo ENV_NA

            # xDeploy deps
            python3 - <<'PY'
import pkgutil, packaging.version as pv
try:
    import ansible
    ok1 = pv.parse(ansible.__version__).release[:2]==(2,15)
except Exception:
    ok1 = False
ok2 = pkgutil.find_loader('kolla_ansible') is not None
print('XDEP_OK' if (ok1 and ok2) else 'XDEP_MISS')
PY

            # Config & passwords
            [ -d /etc/xavs ] && echo CFG_OK || echo CFG_MISS
            [ -f /etc/xavs/passwords.yml ] || [ -f /etc/kolla/passwords.yml ] &&
            echo PWD_OK || echo PWD_MISS
        `;

        try {
            const out = await cockpit.spawn(["bash", "-c", script], { superuser: "try" });
            const results = out.trim().split("\n");
            
            setBadge("dep-py",   results.includes("PY_OK")   ? "ok" : "err",  results.includes("PY_OK")   ? "ok" : "missing");
            setBadge("dep-env",  "warn", "N/A");
            setBadge("dep-xdep", results.includes("XDEP_OK") ? "ok" : "err",  results.includes("XDEP_OK") ? "ok" : "missing");
            setBadge("dep-cfg",  results.includes("CFG_OK")  ? "ok" : "err",  results.includes("CFG_OK")  ? "ready" : "missing");
            setBadge("dep-pwd",  results.includes("PWD_OK")  ? "ok" : "warn", results.includes("PWD_OK")  ? "ready" : "generate");
            
            setText("dep-status", "Checked");
            log("[Deps:RHEL] Check\n" + out.trim());
        } catch (error) {
            log("[Deps:RHEL] Check failed: " + error.message || error);
        }
    }

    async function installDependencies() {
        if (osInfo.isXOS) return;
        
        const installBtn = $("btn-install-all");
        if (installBtn) installBtn.disabled = true;
        
        pb("dep-progress", 0);
        setText("dep-note", "Installing…");

        if (osInfo.branch === "debian") {
            await installDebianDeps();
        } else if (osInfo.branch === "rhel") {
            await installRHELDeps();
        }

        await checkDependencies();
        setText("dep-note", "Done.");
        if (installBtn) installBtn.disabled = false;
    }

    // ——— Event Listeners ———
    $("btn-detect-os").addEventListener("click", detectOS);
    $("btn-run-hw-top").addEventListener("click", () => {
        document.querySelector('#tabs .nav-link[data-target="panel-hw"]').click();
    });
    $("btn-run-hw").addEventListener("click", runHardwareChecks);
    $("btn-check-deps").addEventListener("click", checkDependencies);
    $("btn-install-all").addEventListener("click", installDependencies);
    $("btn-refresh").addEventListener("click", async () => {
        await detectOS();
        await runHardwareChecks();
        await checkDependencies();
    });
    $("btn-clear-log").addEventListener("click", () => {
        if (logEl) logEl.textContent = "";
    });

    // Initialize with first tab and detect OS
    showPanel('panel-overview');
    detectOS().catch(console.error);
})();
